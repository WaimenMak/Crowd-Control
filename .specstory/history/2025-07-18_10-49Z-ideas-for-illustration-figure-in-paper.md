<!-- Generated by SpecStory -->

# Ideas for illustration figure in paper (2025-07-18 10:49Z)

_**User**_

@PRD.md @/README.assets @README.md According to you knowledge of this project, I would like you to provide some ideas on creating an illustration figure for my simulation model for a paper, to showcase the function, different modules and the workflow

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user is asking for ideas for creating an illustration figure for their simulation model to showcase in a paper. They want to showcase the function, different modules, and workflow of their Crowd Control pedestrian traffic simulation tool.

Based on the information provided:

1. **Project Overview**: This is a pedestrian traffic simulation tool based on the Link Transmission Model (LTM)
2. **Core Components**: 
   - Network with nodes and links
   - Link module (pathways with traffic dynamics)
   - Node module (intersections/decision points)
   - OD Manager (origin-destination demand)
   - Path Finder (routing between nodes)
   - Visualization utilities

3. **Current Features**: Complete simulation engine with visualization capabilities
4. **Target**: Academic paper illustration

Let me first explore the codebase to better understand the modules and their relationships, then provide concrete ideas for illustrations.</details></think>

---

I'll help you create ideas for an illustration figure for your paper. Let me first explore the codebase to better understand the modules and their workflow, then provide you with comprehensive illustration concepts.

---

<details>
            <summary>Searched codebase "What are the main components and modules of the LTM simulation system?" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/LTM/Usage.md` | L1-48 |
| `src/LTM/Usage.md` | L48-126 |
| `src/LTM/__init__.py` | L1-22 |
| `src/LTM/Usage.md` | L126-166 |
| `src/LTM/network.py` | L52-88 |
| `src/LTM/network.py` | L1-52 |
| `src/LTM/Usage.md` | L166-233 |
| `src/LTM/od_manager.py` | L1-45 |
| `src/LTM/network.py` | L165-204 |
| `src/LTM/link.py` | L28-70 |
| `src/LTM/link.py` | L1-28 |
| `src/LTM/node.py` | L1-42 |
| `src/LTM/Usage.md` | L233-252 |
| `src/LTM/od_manager.py` | L50-80 |
| `src/LTM/path_finder.py` | L110-135 |
| `src/LTM/link.py` | L70-109 |
| `src/LTM/network.py` | L88-112 |
| `src/LTM/node.py` | L224-242 |
| `src/LTM/node.py` | L271-302 |
| `src/LTM/node.py` | L242-271 |
| `src/LTM/network.py` | L112-165 |
| `src/LTM/network.py` | L234-257 |
| `src/LTM/node.py` | L213-224 |
| `src/LTM/path_finder.py` | L135-172 |
| `src/LTM/link.py` | L236-269 |

</details>

---

<details>
            <summary>Searched codebase "How does the simulation workflow and network execution work?" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/LTM/Usage.md` | L48-126 |
| `src/LTM/network.py` | L52-88 |
| `src/LTM/network.py` | L234-257 |
| `src/LTM/network.py` | L165-204 |
| `src/LTM/network.py` | L88-112 |
| `src/LTM/Usage.md` | L1-48 |
| `src/LTM/network.py` | L1-52 |
| `src/LTM/od_manager.py` | L1-45 |
| `src/LTM/network.py` | L204-234 |
| `src/LTM/Usage.md` | L166-233 |
| `src/LTM/node.py` | L181-213 |
| `src/LTM/Usage.md` | L233-252 |
| `src/LTM/node.py` | L213-224 |
| `src/LTM/node.py` | L224-242 |
| `src/LTM/node.py` | L162-181 |
| `src/LTM/link.py` | L1-28 |
| `src/LTM/node.py` | L242-271 |
| `src/LTM/network.py` | L112-165 |
| `src/LTM/node.py` | L271-302 |
| `src/LTM/node.py` | L1-42 |
| `src/LTM/path_finder.py` | L110-135 |
| `src/LTM/node.py` | L143-162 |
| `src/LTM/path_finder.py` | L135-172 |
| `src/LTM/link.py` | L28-70 |
| `src/LTM/link.py` | L341-376 |

</details>

---

Read file: src/LTM/network.py

---

<think><details><summary>Thought Process</summary>Based on my exploration of the codebase, I now have a comprehensive understanding of the Crowd Control pedestrian traffic simulation system. Let me analyze the key components and workflow to provide ideas for illustration figures for an academic paper.

Key Components I've identified:
1. **Core Architecture**: Network-based simulation with nodes and links
2. **LTM Components**:
   - `Network`: Main orchestrator class
   - `Link`/`BaseLink`: Physical pathways with traffic dynamics 
   - `Node` (OneToOneNode, RegularNode): Intersections/decision points
   - `ODManager`: Origin-destination demand management
   - `PathFinder`: Route calculation and turning probabilities
   - `DemandGenerator`: Various demand patterns

3. **Workflow**: 
   - Initialize network from adjacency matrix
   - Set up nodes and links with parameters
   - Calculate paths between O-D pairs
   - Run simulation step-by-step via `network_loading()`
   - Update link states (density, speed, flows)

4. **Key Features**:
   - Link Transmission Model for traffic dynamics
   - Fundamental diagram for speed-density relationships
   - Flow conservation at nodes
   - Dynamic routing via pathfinding
   - Visualization capabilities

Let me provide comprehensive ideas for academic figures that showcase these aspects.</details></think>

---

Based on my analysis of your Crowd Control pedestrian traffic simulation system, I'll provide you with several illustration figure ideas that effectively showcase the function, modules, and workflow for your academic paper. Here are my recommendations:

## 1. **System Architecture Overview Figure**

Create a multi-panel figure showing:

**Panel A: Conceptual Framework**
- Show the Link Transmission Model concept with a simple 3-node network
- Illustrate pedestrians as discrete entities moving through links
- Show density gradients and fundamental diagram relationship

**Panel B: Module Architecture Diagram**
```
┌─────────────────────────────────────────────────┐
│                    Network                      │
│  ┌─────────────┐  ┌─────────────┐  ┌──────────┐ │
│  │ ODManager   │  │ PathFinder  │  │ Demand   │ │
│  │             │  │             │  │Generator │ │
│  └─────────────┘  └─────────────┘  └──────────┘ │
│  ┌─────────────────┐  ┌─────────────────────────┐ │
│  │     Nodes       │  │        Links            │ │
│  │ • RegularNode   │  │ • Physical pathways     │ │
│  │ • OneToOneNode  │  │ • Traffic dynamics      │ │
│  │ • Origin/Dest   │  │ • Flow calculations     │ │
│  └─────────────────┘  └─────────────────────────┘ │
└─────────────────────────────────────────────────┘
```

## 2. **Simulation Workflow Flowchart**

Create a comprehensive flowchart showing:

```
START → Initialize Network → Setup O-D Flows → Calculate Paths
  ↓
For each time step t:
  ↓
Calculate Turning Fractions → Calculate Sending/Receiving Flows
  ↓
Solve Flow Assignment → Update Link States → Update Speeds/Density
  ↓
t < max_steps? → YES (loop back) / NO → END
```

## 3. **Link Transmission Model Mechanics Figure**

**Panel A: Link Dynamics**
- Show a single link with pedestrian density profile
- Illustrate sending flow calculation with travel time τ
- Show receiving flow with shockwave propagation
- Include fundamental diagram (speed vs density)

**Panel B: Node Flow Assignment**
- Visualize flow conservation at a 4-way intersection
- Show turning fractions and flow splitting
- Illustrate constraint matrices (A_ub, A_eq)

## 4. **Multi-Scale Simulation Demonstration**

Create a figure with three scales:

**Panel A: Network Level**
- Show complete network topology with origin/destination nodes
- Color-code links by density or flow rates
- Show multiple O-D paths overlaid

**Panel B: Link Level** 
- Zoom into a single link showing:
  - Pedestrian density evolution over time
  - Speed-density relationship
  - Cumulative inflow/outflow curves

**Panel C: Node Level**
- Detailed view of intersection with:
  - Incoming/outgoing flows
  - Turning fractions visualization
  - Flow assignment results

## 5. **Dynamic Behavior Showcase**

**Time Series Panel:**
- Multiple subplots showing:
  - Total network density over time
  - Flow rates at key bottlenecks
  - Average travel times
  - Demand patterns (Gaussian peaks, sudden surges)

**Animation Stills:**
- Show 4-6 time snapshots of network evolution
- Use color gradients for density/speed
- Include arrows for flow directions

## 6. **Pathfinding and Route Choice Figure**

**Panel A: Path Discovery**
- Show k-shortest paths between O-D pairs
- Illustrate path overlapping at nodes
- Display path utilities and selection probabilities

**Panel B: Dynamic Routing**
- Show how congestion affects route choice
- Compare paths under different congestion scenarios
- Illustrate logit model route selection

## 7. **Validation and Applications Figure**

**Panel A: Model Validation**
- Comparison plots with real-world data or microscopic simulation
- Fundamental diagram validation
- Flow-density scatter plots

**Panel B: Application Scenarios**
- Show different network configurations (corridor, grid, hub-spoke)
- Demonstrate various demand patterns
- Illustrate control strategies (gate widths, flow regulation)

## 8. **Implementation and Software Architecture**

Create a UML-style diagram showing:
- Class relationships and inheritance
- Key methods and attributes
- Data flow between components
- Input/output structure

## Specific Recommendations:

1. **Use consistent color schemes** - e.g., blue-to-red for density, green-to-yellow for speed
2. **Include mathematical notation** - show key LTM equations alongside visual elements  
3. **Add scale bars and legends** - ensure all quantities are clearly labeled
4. **Consider interactive elements** - if submitting to a digital journal, QR codes linking to animations
5. **Use your existing visualization capabilities** - leverage your `visualizer.py` and `network_dashboard.py` modules

## Figure Quality Tips:

- Use vector graphics (SVG/PDF) for crisp text and lines
- Maintain consistent fonts and sizing across panels
- Include clear captions explaining each component
- Consider colorblind-friendly palettes
- Add grid references or coordinate systems where appropriate

The most impactful figure would likely be **#3 (Link Transmission Model Mechanics)** combined with **#4 (Multi-Scale Demonstration)**, as these directly showcase your model's unique capabilities and demonstrate the system working at different scales of detail.

Would you like me to help you implement any of these visualization concepts using your existing codebase?

---

_**User**_

yes

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants me to help implement the visualization concepts I suggested using their existing codebase. I should look at their current visualization capabilities and suggest concrete implementations. Let me first explore their visualization modules and understand what they already have.</details></think>

---

I'll help you implement these visualization concepts using your existing codebase. Let me first explore your current visualization capabilities and then provide concrete implementation suggestions.

---

<details>
            <summary>Searched codebase "What visualization and plotting capabilities are currently available?" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/utils/visualizer.py` | L634-652 |
| `src/utils/visualizer.py` | L1-39 |
| `src/utils/visualizer.py` | L570-599 |
| `src/utils/visualizer.py` | L189-237 |
| `src/utils/visualizer.py` | L599-626 |
| `src/utils/visualizer.py` | L58-83 |
| `src/utils/visualizer.py` | L378-425 |
| `src/utils/visualizer.py` | L237-268 |
| `src/utils/visualizer.py` | L150-189 |
| `src/utils/visualizer.py` | L466-497 |
| `src/utils/visualizer.py` | L39-58 |
| `src/utils/visualizer.py` | L542-570 |
| `src/utils/visualizer.py` | L425-466 |
| `src/utils/visualizer.py` | L343-378 |
| `src/utils/visualizer.py` | L108-150 |
| `src/utils/visualizer.py` | L83-108 |
| `src/utils/visualizer.py` | L268-309 |
| `src/utils/visualizer.py` | L309-343 |
| `src/utils/visualizer.py` | L497-542 |
| `src/utils/visualizer.py` | L626-634 |
| `src/utils/functions.py` | L1-24 |
| `src/utils/config.py` | L1-47 |
| `src/utils/functions.py` | L24-55 |
| `src/utils/env_loader.py` | L131-138 |
| `src/utils/env_loader.py` | L29-76 |

</details>

---

<details>
            <summary>Searched codebase "visualizer" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

<details>
            <summary>Searched codebase "dashboard" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

<think><details><summary>Thought Process</summary>Great! I can see they have a comprehensive visualization system already. Let me look at the network_dashboard.py to understand their dashboard capabilities, and also explore some examples to understand how they typically visualize their networks.</details></think>

---

Read file: network_dashboard.py

---

<details>
            <summary>Searched codebase "How are simulation examples and visualizations typically created?" • **21** results</summary>
        
| File | Lines |
|------|-------|
| `examples/six_node.py` | L1-48 |
| `examples/delft_exp.py` | L1-56 |
| `examples/nine_node.py` | L68-101 |
| `examples/long_corridor.py` | L112-161 |
| `examples/spike.py` | L78-131 |
| `examples/big_network.py` | L1-66 |
| `examples/spike.py` | L131-150 |
| `examples/big_network_directions.py` | L65-92 |
| `examples/Melbourne.py` | L36-72 |
| `examples/forky_queues.py` | L109-150 |
| `examples/spike.py` | L1-78 |
| `examples/nine_node.py` | L1-68 |
| `examples/big_network.py` | L66-78 |
| `examples/big_network_directions.py` | L1-65 |
| `examples/long_corridor.py` | L1-61 |
| `examples/Melbourne.py` | L1-36 |
| `examples/forky_queues.py` | L40-109 |
| `examples/long_corridor.py` | L61-112 |
| `examples/forky_queues.py` | L1-40 |
| `examples/long_corridor.py` | L161-182 |
| `examples/six_node.py` | L48-51 |

</details>

---

<think><details><summary>Thought Process</summary>Perfect! Now I have a comprehensive understanding of their existing codebase. They have:

1. **NetworkVisualizer class** - A comprehensive visualization system that can:
   - Create network state visualizations at specific time steps
   - Generate animations over time
   - Support both NetworkX-based and Folium-based (interactive map) visualizations
   - Plot link evolution over time
   - Support different edge properties (density, flow, speed, num_pedestrians)

2. **NetworkDashboard class** - An interactive Streamlit-based dashboard for real-time exploration

3. **Multiple examples** showing different simulation scenarios (corridor, grid networks, real street networks like Delft and Melbourne)

4. **Output handling** - They save simulation results and can reload them for visualization

5. **Flexible configuration system** using YAML files

Now I can provide concrete implementations for the illustration figures I suggested earlier. Let me create specific code implementations for the most impactful visualizations.</details></think>

---

Perfect! Now I understand your comprehensive visualization system. Let me provide you with concrete implementations for the most impactful academic figure concepts, building on your existing `NetworkVisualizer` and capabilities.

I'll create specific code for the **Link Transmission Model Mechanics Figure** and **Multi-Scale Simulation Demonstration** as these would be most suitable for your paper.

---

Read file: src/utils/visualizer.py

---

<think><details><summary>Thought Process</summary>Perfect! Now I'll create implementations for several academic figure concepts. Let me create a comprehensive Python script that generates the most impactful visualizations for their paper.</details></think>

---

Now I'll create comprehensive code implementations for academic figures. Let me create a new Python script that extends your existing visualization capabilities:

---

Read file: src/utils/visualizer.py

---

<think><details><summary>Thought Process</summary>Let me create a new file that extends the visualization capabilities for academic paper figures. I'll provide complete, working code that builds on their existing system.</details></think>

---

Now I'll create a comprehensive script for generating academic paper figures. Here's the implementation:

```python
# academic_figures.py
"""
Academic Paper Visualization Generator for Crowd Control LTM Simulation
Extends the existing NetworkVisualizer class with specialized figure generation for academic papers.
"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.gridspec as gridspec
from matplotlib.patches import FancyBboxPatch, ConnectionPatch
import networkx as nx
import json
import os
from pathlib import Path
from src.utils.visualizer import NetworkVisualizer
from src.utils.functions import SpeedDensityFd
from src.LTM.network import Network

class AcademicFigureGenerator:
    """Generates publication-ready figures for the LTM pedestrian simulation"""
    
    def __init__(self, visualizer=None, simulation_dir=None, network=None):
        """
        Initialize with either a NetworkVisualizer, simulation directory, or network object
        """
        if visualizer is not None:
            self.visualizer = visualizer
            self.network = visualizer.network
        elif simulation_dir is not None:
            self.visualizer = NetworkVisualizer(simulation_dir=simulation_dir)
            self.network = None
        elif network is not None:
            self.visualizer = NetworkVisualizer(network=network)
            self.network = network
        else:
            raise ValueError("Must provide either visualizer, simulation_dir, or network")
    
    def create_system_architecture_figure(self, save_path=None, figsize=(16, 10)):
        """
        Create Figure 1: System Architecture Overview
        Shows conceptual framework and module architecture
        """
        fig = plt.figure(figsize=figsize)
        gs = gridspec.GridSpec(2, 3, height_ratios=[1, 1], width_ratios=[1, 1, 1])
        
        # Panel A: Conceptual Framework (LTM concept)
        ax1 = fig.add_subplot(gs[0, :2])
        self._draw_ltm_concept(ax1)
        ax1.set_title('(A) Link Transmission Model Concept', fontsize=14, fontweight='bold')
        
        # Panel B: Module Architecture
        ax2 = fig.add_subplot(gs[0, 2])
        self._draw_module_architecture(ax2)
        ax2.set_title('(B) Module Architecture', fontsize=14, fontweight='bold')
        
        # Panel C: Fundamental Diagram
        ax3 = fig.add_subplot(gs[1, 0])
        self._draw_fundamental_diagram(ax3)
        ax3.set_title('(C) Speed-Density Relationship', fontsize=14, fontweight='bold')
        
        # Panel D: Node Flow Assignment
        ax4 = fig.add_subplot(gs[1, 1:])
        self._draw_node_mechanics(ax4)
        ax4.set_title('(D) Node Flow Assignment Mechanics', fontsize=14, fontweight='bold')
        
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        return fig
    
    def create_workflow_figure(self, save_path=None, figsize=(14, 10)):
        """
        Create Figure 2: Simulation Workflow Flowchart
        """
        fig, ax = plt.subplots(figsize=figsize)
        
        # Define workflow steps
        steps = [
            "Initialize Network\n(Adjacency Matrix + Parameters)",
            "Setup Origin-Destination\nFlows & Demand Patterns",
            "Calculate K-Shortest\nPaths Between O-D Pairs",
            "For Each Time Step t:",
            "Calculate Dynamic\nTurning Fractions",
            "Compute Sending &\nReceiving Flows",
            "Solve Flow Assignment\n(Linear Programming)",
            "Update Link States\n(Density, Speed, Flow)",
            "t < max_steps?",
            "END"
        ]
        
        self._draw_workflow_flowchart(ax, steps)
        ax.set_title('Simulation Workflow', fontsize=16, fontweight='bold')
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 12)
        ax.axis('off')
        
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        return fig
    
    def create_link_mechanics_figure(self, link_id=(0,1), time_steps=None, save_path=None, figsize=(16, 12)):
        """
        Create Figure 3: Link Transmission Model Mechanics
        Shows detailed link dynamics with sending/receiving flows
        """
        if time_steps is None:
            time_steps = [50, 100, 150, 200]
        
        fig = plt.figure(figsize=figsize)
        gs = gridspec.GridSpec(3, 4, height_ratios=[1, 1, 1])
        
        # Get link data
        if self.visualizer.from_saved:
            link_key = f"{link_id[0]}-{link_id[1]}"
            link_data = self.visualizer.link_data[link_key]
        else:
            link_data = self.network.links[link_id]
        
        # Row 1: Link state at different time steps
        for i, t in enumerate(time_steps):
            ax = fig.add_subplot(gs[0, i])
            self._draw_link_state(ax, link_data, t, f"t = {t}")
        
        # Row 2: Time series plots
        ax_density = fig.add_subplot(gs[1, :2])
        ax_flow = fig.add_subplot(gs[1, 2:])
        self._draw_link_time_series(ax_density, ax_flow, link_data)
        
        # Row 3: Fundamental diagram and flow calculations
        ax_fd = fig.add_subplot(gs[2, :2])
        ax_calc = fig.add_subplot(gs[2, 2:])
        self._draw_fundamental_diagram_detailed(ax_fd)
        self._draw_flow_calculations(ax_calc, link_data, time_steps[1])
        
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        return fig
    
    def create_multiscale_figure(self, time_step=100, save_path=None, figsize=(18, 12)):
        """
        Create Figure 4: Multi-Scale Simulation Demonstration
        Shows network, link, and node levels simultaneously
        """
        fig = plt.figure(figsize=figsize)
        gs = gridspec.GridSpec(2, 3, height_ratios=[1, 1], width_ratios=[2, 1, 1])
        
        # Panel A: Network Level (large)
        ax_network = fig.add_subplot(gs[:, 0])
        self.visualizer._visualize_network_nx(time_step, edge_property='density', with_colorbar=True)
        plt.sca(ax_network)
        plt.title('(A) Network Level View', fontsize=14, fontweight='bold')
        
        # Panel B: Link Level Detail
        ax_link = fig.add_subplot(gs[0, 1])
        self._draw_link_detail(ax_link, time_step)
        ax_link.set_title('(B) Link Level Detail', fontsize=12, fontweight='bold')
        
        # Panel C: Node Level Detail  
        ax_node = fig.add_subplot(gs[0, 2])
        self._draw_node_detail(ax_node, time_step)
        ax_node.set_title('(C) Node Level Detail', fontsize=12, fontweight='bold')
        
        # Panel D: Dynamic Behavior
        ax_dynamics = fig.add_subplot(gs[1, 1:])
        self._draw_network_dynamics(ax_dynamics)
        ax_dynamics.set_title('(D) Network Dynamics Over Time', fontsize=12, fontweight='bold')
        
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        return fig
    
    def create_pathfinding_figure(self, od_pair=(0, 5), save_path=None, figsize=(14, 8)):
        """
        Create Figure 5: Pathfinding and Route Choice
        """
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=figsize)
        
        # Panel A: Path Discovery
        self._draw_path_discovery(ax1, od_pair)
        ax1.set_title('(A) K-Shortest Path Discovery', fontsize=12, fontweight='bold')
        
        # Panel B: Dynamic Route Choice
        self._draw_route_choice(ax2, od_pair)
        ax2.set_title('(B) Dynamic Route Selection', fontsize=12, fontweight='bold')
        
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=300, bbox_inches='tight')
        return fig
    
    # Helper methods for drawing specific components
    def _draw_ltm_concept(self, ax):
        """Draw the basic LTM concept with links and nodes"""
        # Draw a simple 3-node network with pedestrian representation
        nodes = [(1, 2), (3, 2), (5, 2)]
        node_labels = ['Origin', 'Intersection', 'Destination']
        
        # Draw nodes
        for i, (x, y) in enumerate(nodes):
            if i == 0:  # Origin
                color = 'lightcoral'
            elif i == 2:  # Destination
                color = 'lightgreen'
            else:  # Intersection
                color = 'lightblue'
            
            circle = plt.Circle((x, y), 0.2, color=color, ec='black', linewidth=2)
            ax.add_patch(circle)
            ax.text(x, y-0.5, node_labels[i], ha='center', va='top', fontsize=10, fontweight='bold')
        
        # Draw links with density representation
        link_coords = [((1.2, 2), (2.8, 2)), ((3.2, 2), (4.8, 2))]
        densities = [0.3, 0.7]  # Different density levels
        
        for i, ((x1, y1), (x2, y2)) in enumerate(link_coords):
            # Draw link background
            rect = plt.Rectangle((x1, y1-0.1), x2-x1, 0.2, color='lightgray', alpha=0.5)
            ax.add_patch(rect)
            
            # Draw pedestrians as dots (density visualization)
            n_peds = int(densities[i] * 20)
            for j in range(n_peds):
                x_ped = x1 + (x2-x1) * (j/max(1, n_peds-1))
                y_ped = y1 + np.random.uniform(-0.05, 0.05)
                ax.plot(x_ped, y_ped, 'o', color='red', markersize=3)
            
            # Add density label
            ax.text((x1+x2)/2, y1+0.3, f'ρ = {densities[i]:.1f}', ha='center', fontsize=9)
            
            # Add flow arrow
            ax.annotate('', xy=(x2-0.1, y2), xytext=(x1+0.1, y1),
                       arrowprops=dict(arrowstyle='->', lw=2, color='blue'))
        
        ax.set_xlim(0, 6)
        ax.set_ylim(1, 3)
        ax.set_aspect('equal')
        ax.axis('off')
    
    def _draw_module_architecture(self, ax):
        """Draw the module architecture diagram"""
        # Define module boxes
        modules = {
            'Network': (0.5, 0.8, 0.4, 0.15),
            'ODManager': (0.05, 0.5, 0.25, 0.12),
            'PathFinder': (0.35, 0.5, 0.25, 0.12),
            'DemandGen': (0.7, 0.5, 0.25, 0.12),
            'Nodes': (0.05, 0.2, 0.4, 0.12),
            'Links': (0.55, 0.2, 0.4, 0.12)
        }
        
        colors = {
            'Network': 'lightblue',
            'ODManager': 'lightcoral',
            'PathFinder': 'lightgreen', 
            'DemandGen': 'lightyellow',
            'Nodes': 'lavender',
            'Links': 'lightcyan'
        }
        
        # Draw modules
        for name, (x, y, w, h) in modules.items():
            rect = FancyBboxPatch((x, y), w, h, boxstyle="round,pad=0.01",
                                facecolor=colors[name], edgecolor='black', linewidth=1)
            ax.add_patch(rect)
            ax.text(x + w/2, y + h/2, name, ha='center', va='center', 
                   fontsize=9, fontweight='bold')
        
        # Draw connections
        connections = [
            ('Network', 'ODManager'),
            ('Network', 'PathFinder'),
            ('Network', 'DemandGen'),
            ('Network', 'Nodes'),
            ('Network', 'Links')
        ]
        
        for source, target in connections:
            x1, y1, w1, h1 = modules[source]
            x2, y2, w2, h2 = modules[target]
            
            # Calculate connection points
            if y1 > y2:  # Downward connection
                start = (x1 + w1/2, y1)
                end = (x2 + w2/2, y2 + h2)
            else:  # Upward connection
                start = (x1 + w1/2, y1 + h1)
                end = (x2 + w2/2, y2)
            
            ax.annotate('', xy=end, xytext=start,
                       arrowprops=dict(arrowstyle='->', lw=1, color='gray'))
        
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.axis('off')
    
    def _draw_fundamental_diagram(self, ax):
        """Draw speed-density fundamental diagram"""
        # Create speed-density relationship
        density = np.linspace(0, 10, 100)
        v_f = 1.5
        k_critical = 2
        k_jam = 10
        
        speed = np.where(density <= k_critical, 
                        v_f,
                        np.maximum(0, -v_f * (density - k_jam) / (k_jam - k_critical)))
        
        ax.plot(density, speed, 'b-', linewidth=3, label='Speed-Density')
        ax.axvline(k_critical, color='r', linestyle='--', alpha=0.7, label=f'Critical Density ({k_critical})')
        ax.axvline(k_jam, color='orange', linestyle='--', alpha=0.7, label=f'Jam Density ({k_jam})')
        
        ax.set_xlabel('Density (ped/m²)', fontsize=12)
        ax.set_ylabel('Speed (m/s)', fontsize=12)
        ax.legend()
        ax.grid(True, alpha=0.3)
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 1.6)
    
    def _draw_node_mechanics(self, ax):
        """Draw node flow assignment mechanics"""
        # Draw a 4-way intersection
        center = (0.5, 0.5)
        radius = 0.1
        
        # Draw central node
        circle = plt.Circle(center, radius, color='lightblue', ec='black', linewidth=2)
        ax.add_patch(circle)
        
        # Draw incoming and outgoing links
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Up, Right, Down, Left
        link_length = 0.3
        
        sending_flows = [10, 8, 0, 5]  # Example sending flows
        receiving_flows = [12, 6, 15, 9]  # Example receiving flows
        
        for i, (dx, dy) in enumerate(directions):
            start_x = center[0] + dx * radius
            start_y = center[1] + dy * radius
            end_x = start_x + dx * link_length
            end_y = start_y + dy * link_length
            
            # Draw link
            ax.plot([start_x, end_x], [start_y, end_y], 'k-', linewidth=4, alpha=0.7)
            
            # Add flow labels
            if i < 2:  # Incoming flows (up and right)
                ax.text(end_x + dx*0.05, end_y + dy*0.05, f'S={sending_flows[i]}', 
                       ha='center', va='center', fontsize=10, 
                       bbox=dict(boxstyle="round,pad=0.3", facecolor='lightcoral'))
            else:  # Outgoing flows (down and left)
                ax.text(end_x + dx*0.05, end_y + dy*0.05, f'R={receiving_flows[i]}', 
                       ha='center', va='center', fontsize=10,
                       bbox=dict(boxstyle="round,pad=0.3", facecolor='lightgreen'))
        
        # Add turning fractions
        ax.text(center[0], center[1], 'Flow\nAssignment', ha='center', va='center', 
               fontsize=10, fontweight='bold')
        
        # Add constraint equation
        ax.text(0.1, 0.9, r'$\sum_{i} q_{ij} \leq S_i$ (Sending constraint)', 
               fontsize=11, transform=ax.transAxes)
        ax.text(0.1, 0.85, r'$\sum_{i} q_{ij} \leq R_j$ (Receiving constraint)', 
               fontsize=11, transform=ax.transAxes)
        
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.set_aspect('equal')
        ax.axis('off')
    
    def _draw_workflow_flowchart(self, ax, steps):
        """Draw the workflow flowchart"""
        box_width = 2
        box_height = 0.8
        y_spacing = 1.2
        
        # Position boxes
        y_positions = [11 - i * y_spacing for i in range(len(steps))]
        x_center = 5
        
        for i, (step, y) in enumerate(zip(steps, y_positions)):
            # Special handling for decision diamond
            if "t < max_steps?" in step:
                # Draw diamond
                diamond_points = np.array([
                    [x_center, y + 0.4],  # Top
                    [x_center + 1, y],    # Right
                    [x_center, y - 0.4],  # Bottom
                    [x_center - 1, y]     # Left
                ])
                diamond = patches.Polygon(diamond_points, closed=True, 
                                        facecolor='yellow', edgecolor='black')
                ax.add_patch(diamond)
                ax.text(x_center, y, step, ha='center', va='center', 
                       fontsize=9, fontweight='bold')
                
                # Add YES/NO branches
                ax.text(x_center - 2, y - 0.6, 'YES', ha='center', va='center', 
                       fontsize=10, fontweight='bold', color='green')
                ax.text(x_center + 2, y - 0.6, 'NO', ha='center', va='center', 
                       fontsize=10, fontweight='bold', color='red')
                
            else:
                # Regular box
                if "For Each Time Step" in step:
                    color = 'lightcoral'
                elif "END" in step:
                    color = 'lightgreen'
                else:
                    color = 'lightblue'
                
                rect = FancyBboxPatch((x_center - box_width/2, y - box_height/2), 
                                    box_width, box_height, boxstyle="round,pad=0.1",
                                    facecolor=color, edgecolor='black')
                ax.add_patch(rect)
                ax.text(x_center, y, step, ha='center', va='center', 
                       fontsize=9, fontweight='bold')
            
            # Draw arrows (except for last step)
            if i < len(steps) - 1:
                if "t < max_steps?" in step:
                    # Loop back arrow (YES)
                    ax.annotate('', xy=(x_center - 2, y_positions[4]), 
                               xytext=(x_center - 1, y - 0.4),
                               arrowprops=dict(arrowstyle='->', lw=2, color='green'))
                    # Continue arrow (NO)
                    ax.annotate('', xy=(x_center, y_positions[i+1] + box_height/2), 
                               xytext=(x_center + 1, y - 0.4),
                               arrowprops=dict(arrowstyle='->', lw=2, color='red'))
                elif "END" not in step and "END" not in steps[i+1]:
                    ax.annotate('', xy=(x_center, y_positions[i+1] + box_height/2), 
                               xytext=(x_center, y - box_height/2),
                               arrowprops=dict(arrowstyle='->', lw=2, color='black'))
    
    def _draw_link_state(self, ax, link_data, time_step, title):
        """Draw link state at specific time step"""
        if self.visualizer.from_saved:
            density = link_data['density'][time_step]
            speed = link_data['speed'][time_step]
            flow = link_data['link_flow'][time_step]
        else:
            density = link_data.density[time_step]
            speed = link_data.speed[time_step]
            flow = link_data.link_flow[time_step]
        
        # Draw link as rectangle
        rect = plt.Rectangle((0, 0), 4, 1, facecolor='lightgray', edgecolor='black')
        ax.add_patch(rect)
        
        # Add pedestrians based on density
        n_peds = int(density * 10)
        for i in range(min(n_peds, 20)):  # Cap visualization
            x = 0.2 + i * 0.18
            y = 0.5 + np.random.uniform(-0.2, 0.2)
            ax.plot(x, y, 'ro', markersize=4)
        
        # Add metrics
        ax.text(2, 1.3, title, ha='center', fontsize=11, fontweight='bold')
        ax.text(2, -0.3, f'ρ={density:.2f}, v={speed:.2f}, q={flow:.2f}', 
               ha='center', fontsize=9)
        
        ax.set_xlim(-0.5, 4.5)
        ax.set_ylim(-0.5, 1.5)
        ax.set_aspect('equal')
        ax.axis('off')
    
    def _draw_link_time_series(self, ax_density, ax_flow, link_data):
        """Draw time series of link properties"""
        if self.visualizer.from_saved:
            time = range(len(link_data['density']))
            density = link_data['density']
            inflow = link_data['inflow']
            outflow = link_data['outflow']
        else:
            time = range(len(link_data.density))
            density = link_data.density
            inflow = link_data.inflow
            outflow = link_data.outflow
        
        # Density plot
        ax_density.plot(time, density, 'b-', linewidth=2, label='Density')
        ax_density.set_ylabel('Density (ped/m²)')
        ax_density.set_xlabel('Time Step')
        ax_density.grid(True, alpha=0.3)
        ax_density.legend()
        
        # Flow plot
        ax_flow.plot(time, inflow, 'g--', linewidth=2, label='Inflow')
        ax_flow.plot(time, outflow, 'r-', linewidth=2, label='Outflow')
        ax_flow.set_ylabel('Flow (ped/s)')
        ax_flow.set_xlabel('Time Step')
        ax_flow.grid(True, alpha=0.3)
        ax_flow.legend()
    
    def _draw_fundamental_diagram_detailed(self, ax):
        """Draw detailed fundamental diagram with operating points"""
        # Same as _draw_fundamental_diagram but with additional annotations
        self._draw_fundamental_diagram(ax)
        
        # Add example operating points
        example_densities = [1, 3, 6]
        for i, d in enumerate(example_densities):
            v_f = 1.5
            k_critical = 2
            k_jam = 10
            
            if d <= k_critical:
                v = v_f
            else:
                v = max(0, -v_f * (d - k_jam) / (k_jam - k_critical))
            
            ax.plot(d, v, 'ro', markersize=8)
            ax.annotate(f'Point {i+1}', xy=(d, v), xytext=(d+0.5, v+0.2),
                       arrowprops=dict(arrowstyle='->', color='red'))
    
    def _draw_flow_calculations(self, ax, link_data, time_step):
        """Draw flow calculation details"""
        # Show sending and receiving flow calculations
        ax.text(0.1, 0.9, 'Sending Flow Calculation:', fontsize=12, fontweight='bold',
               transform=ax.transAxes)
        ax.text(0.1, 0.8, r'$S_i(t) = \min(N_i(t), k_{crit} \cdot v_f \cdot w \cdot \Delta t)$',
               fontsize=11, transform=ax.transAxes)
        
        ax.text(0.1, 0.6, 'Receiving Flow Calculation:', fontsize=12, fontweight='bold',
               transform=ax.transAxes)
        ax.text(0.1, 0.5, r'$R_j(t) = \min(k_{jam} \cdot A - N_j(t), k_{crit} \cdot v_f \cdot w \cdot \Delta t)$',
               fontsize=11, transform=ax.transAxes)
        
        # Add example values
        if self.visualizer.from_saved:
            density = link_data['density'][time_step]
        else:
            density = link_data.density[time_step]
        
        ax.text(0.1, 0.3, f'Example at t={time_step}:', fontsize=12, fontweight='bold',
               transform=ax.transAxes)
        ax.text(0.1, 0.2, f'Density: {density:.2f} ped/m²', fontsize=11,
               transform=ax.transAxes)
        
        ax.axis('off')
    
    def _draw_link_detail(self, ax, time_step):
        """Draw detailed link view"""
        # Select a representative link
        if self.visualizer.from_saved:
            link_key = list(self.visualizer.link_data.keys())[0]
            link_data = self.visualizer.link_data[link_key]
            density = link_data['density'][time_step]
        else:
            link_key = list(self.network.links.keys())[0]
            link_data = self.network.links[link_key]
            density = link_data.density[time_step]
        
        self._draw_link_state(ax, link_data, time_step, f'Link {link_key}')
    
    def _draw_node_detail(self, ax, time_step):
        """Draw detailed node view"""
        # Draw a representative intersection
        self._draw_node_mechanics(ax)
    
    def _draw_network_dynamics(self, ax):
        """Draw network-wide dynamics over time"""
        if self.visualizer.from_saved:
            # Calculate total network metrics
            all_links = list(self.visualizer.link_data.keys())
            time_steps = len(self.visualizer.link_data[all_links[0]]['density'])
            
            total_density = np.zeros(time_steps)
            total_flow = np.zeros(time_steps)
            
            for link_key in all_links:
                link_data = self.visualizer.link_data[link_key]
                total_density += np.array(link_data['density'])
                total_flow += np.array(link_data['link_flow'])
        else:
            time_steps = self.network.simulation_steps
            total_density = np.zeros(time_steps)
            total_flow = np.zeros(time_steps)
            
            for link in self.network.links.values():
                total_density += link.density
                total_flow += link.link_flow
        
        time = range(time_steps)
        
        # Plot total network metrics
        ax_twin = ax.twinx()
        
        line1 = ax.plot(time, total_density, 'b-', linewidth=2, label='Total Density')
        line2 = ax_twin.plot(time, total_flow, 'r-', linewidth=2, label='Total Flow')
        
        ax.set_xlabel('Time Step')
        ax.set_ylabel('Total Density', color='b')
        ax_twin.set_ylabel('Total Flow', color='r')
        
        # Combine legends
        lines1, labels1 = ax.get_legend_handles_labels()
        lines2, labels2 = ax_twin.get_legend_handles_labels()
        ax.legend(lines1 + lines2, labels1 + labels2, loc='upper right')
        
        ax.grid(True, alpha=0.3)
    
    def _draw_path_discovery(self, ax, od_pair):
        """Draw path discovery visualization"""
        # Create a simple network for demonstration
        G = nx.DiGraph()
        # Add nodes in a grid pattern
        pos = {0: (0, 1), 1: (1, 2), 2: (2, 1), 3: (1, 1), 4: (2, 0), 5: (3, 1)}
        
        # Add edges
        edges = [(0, 1), (0, 3), (1, 2), (1, 3), (3, 2), (3, 4), (2, 5), (4, 5)]
        G.add_edges_from(edges)
        
        # Draw network
        nx.draw_networkx_nodes(G, pos, node_color='lightblue', 
                             node_size=500, ax=ax)
        nx.draw_networkx_edges(G, pos, edge_color='gray', ax=ax)
        nx.draw_networkx_labels(G, pos, ax=ax)
        
        # Highlight origin and destination
        origin, dest = od_pair[0] if od_pair[0] in pos else 0, od_pair[1] if od_pair[1] in pos else 5
        nx.draw_networkx_nodes(G, pos, nodelist=[origin], node_color='red',
                             node_size=600, ax=ax)
        nx.draw_networkx_nodes(G, pos, nodelist=[dest], node_color='green',
                             node_size=600, ax=ax)
        
        # Draw multiple paths
        try:
            paths = list(nx.all_simple_paths(G, origin, dest))[:3]  # Get up to 3 paths
            colors = ['red', 'blue', 'orange']
            
            for i, path in enumerate(paths):
                path_edges = [(path[j], path[j+1]) for j in range(len(path)-1)]
                nx.draw_networkx_edges(G, pos, edgelist=path_edges,
                                     edge_color=colors[i], width=3, alpha=0.7, ax=ax)
                
                # Add path label
                ax.text(0.1, 0.9 - i*0.1, f'Path {i+1}: {" → ".join(map(str, path))}',
                       transform=ax.transAxes, color=colors[i], fontweight='bold')
        except:
            pass
        
        ax.set_title(f'Paths from {origin} to {dest}')
        ax.axis('off')
    
    def _draw_route_choice(self, ax, od_pair):
        """Draw route choice visualization"""
        # Show how congestion affects route selection
        time = np.linspace(0, 100, 100)
        
        # Simulate path utilities over time
        path1_utility = 1.0 + 0.3 * np.sin(time * 0.2)  # Varying utility
        path2_utility = 1.2 + 0.2 * np.sin(time * 0.15 + np.pi/4)
        path3_utility = 0.9 + 0.4 * np.sin(time * 0.1 + np.pi/2)
        
        # Calculate selection probabilities (logit model)
        theta = 0.5  # Temperature parameter
        exp_utilities = np.exp(np.array([path1_utility, path2_utility, path3_utility]) / theta)
        total_exp = np.sum(exp_utilities, axis=0)
        
        prob1 = exp_utilities[0] / total_exp
        prob2 = exp_utilities[1] / total_exp
        prob3 = exp_utilities[2] / total_exp
        
        # Plot probabilities
        ax.plot(time, prob1, 'r-', linewidth=2, label='Path 1')
        ax.plot(time, prob2, 'b-', linewidth=2, label='Path 2')
        ax.plot(time, prob3, 'orange', linewidth=2, label='Path 3')
        
        ax.set_xlabel('Time Step')
        ax.set_ylabel('Selection Probability')
        ax.set_ylim(0, 1)
        ax.legend()
        ax.grid(True, alpha=0.3)
        ax.set_title('Dynamic Route Choice Probabilities')

def main():
    """Example usage of the AcademicFigureGenerator"""
    # Example 1: Using saved simulation data
    project_root = Path(__file__).resolve().parent.parent
    simulation_dir = project_root / "outputs" / "nine_node"  # Replace with your simulation
    
    if simulation_dir.exists():
        generator = AcademicFigureGenerator(simulation_dir=str(simulation_dir))
        
        # Generate all figures
        output_dir = project_root / "figures"
        output_dir.mkdir(exist_ok=True)
        
        # Figure 1: System Architecture
        fig1 = generator.create_system_architecture_figure(
            save_path=str(output_dir / "figure1_system_architecture.png")
        )
        
        # Figure 2: Workflow
        fig2 = generator.create_workflow_figure(
            save_path=str(output_dir / "figure2_workflow.png")
        )
        
        # Figure 3: Link Mechanics  
        fig3 = generator.create_link_mechanics_figure(
            save_path=str(output_dir / "figure3_link_mechanics.png")
        )
        
        # Figure 4: Multi-scale
        fig4 = generator.create_multiscale_figure(
            save_path=str(output_dir / "figure4_multiscale.png")
        )
        
        # Figure 5: Pathfinding
        fig5 = generator.create_pathfinding_figure(
            save_path=str(output_dir / "figure5_pathfinding.png")
        )
        
        plt.show()
        print(f"Figures saved to {output_dir}")
    
    else:
        print(f"Simulation directory {simulation_dir} not found.")
        print("Please run a simulation first or update the path.")

if __name__ == "__main__":
    main()
```

Now, here's how to use this system:

## Usage Instructions:

1. **Save the code** as `academic_figures.py` in your project root directory.

2. **Run after a simulation** to generate publication-ready figures:

```bash
# First run one of your existing simulations
python examples/nine_node.py

# Then generate academic figures
python academic_figures.py
```

3. **Customize for your specific needs**:

```python
# In your own script
from academic_figures import AcademicFigureGenerator
from src.utils.visualizer import NetworkVisualizer

# Option 1: Use with existing simulation results
visualizer = NetworkVisualizer(simulation_dir="outputs/your_simulation")
generator = AcademicFigureGenerator(visualizer=visualizer)

# Option 2: Use with live network object
network = Network(adj_matrix, params, origin_nodes, destination_nodes)
# ... run simulation ...
generator = AcademicFigureGenerator(network=network)

# Generate specific figures
fig1 = generator.create_system_architecture_figure(figsize=(20, 12))
fig2 = generator.create_link_mechanics_figure(link_id=(0,1), time_steps=[50, 100, 150])
fig3 = generator.create_multiscale_figure(time_step=100)

# Save with custom paths
fig1.savefig("paper_figures/system_overview.pdf", dpi=300, bbox_inches='tight')
```

## Key Features:

1. **Publication Quality**: 300 DPI, vector graphics, consistent styling
2. **Modular Design**: Generate individual figures or complete sets
3. **Customizable**: Adjust colors, sizes, time steps, link selections
4. **Professional Layout**: Multi-panel figures with proper labeling
5. **Mathematical Notation**: LaTeX-style equations and symbols
6. **Data Integration**: Works with your existing simulation pipeline

## Figure Types Generated:

1. **System Architecture** - Shows LTM concept, modules, and fundamental diagram
2. **Simulation Workflow** - Complete flowchart of your simulation process  
3. **Link Mechanics** - Detailed link dynamics with time series
4. **Multi-scale View** - Network, link, and node levels simultaneously
5. **Pathfinding** - Route discovery and dynamic selection

The figures will be saved in a `figures/` directory and displayed on screen. You can easily modify colors, layouts, and content to match your paper's requirements.

Would you like me to help you customize any specific figure or add additional visualization capabilities?

---


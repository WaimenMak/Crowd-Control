<!-- Generated by SpecStory -->

# Improve adjacency matrix symmetry (2025-07-09 12:38Z)

_**User**_

@node.py @link.py @long_corridor.py when we create the link or separator, the operation on the adjacency matrix is not symetric, eg if we assign the link params for '3_2', it will not be processed by this code, since it only iterate the upper triangular element of the matrix. do you have suggestion to improve it? 

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user is pointing out an issue with how links are created based on the adjacency matrix. Looking at the code they've highlighted from `network.py`, I can see that it only iterates through the upper triangular portion of the adjacency matrix:

```python
for i in range(num_nodes):
    # ... code ...
    for j in range(i+1, num_nodes):
        if self.adjacency_matrix[i, j] == 1:
            # Create forward link (i->j)
```

This means that if someone wants to specify specific parameters for a link like '3_2', it won't be processed because the code only looks at `j > i` (i.e., it would only process '2_3', not '3_2').

Let me search for more context about how links are created and how parameters are assigned to understand the full picture.</details></think>

---

I can see the issue you're pointing out. The current code only iterates through the upper triangular part of the adjacency matrix (`j > i`), which means link-specific configurations for reverse direction links (e.g., '3_2' instead of '2_3') won't be processed. Let me examine the current link creation logic more thoroughly.

---

<details>
            <summary>Searched codebase "How are links created from adjacency matrix and how are link-specific parameters assigned?" â€¢ **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/LTM/network.py` | L133-171 |
| `src/LTM/network.py` | L45-81 |
| `src/LTM/path_finder.py` | L110-133 |
| `src/LTM/network.py` | L81-105 |
| `src/LTM/link.py` | L28-70 |
| `src/LTM/link.py` | L70-114 |
| `src/LTM/network.py` | L171-201 |
| `src/LTM/node.py` | L1-42 |
| `src/LTM/network.py` | L201-224 |
| `src/LTM/node.py` | L162-181 |
| `src/LTM/network.py` | L105-133 |
| `src/LTM/node.py` | L42-64 |
| `src/LTM/link.py` | L154-187 |
| `src/LTM/node.py` | L108-143 |
| `src/LTM/link.py` | L1-28 |
| `src/LTM/node.py` | L64-108 |
| `src/LTM/Usage.md` | L166-233 |
| `src/LTM/node.py` | L181-213 |
| `src/LTM/link.py` | L114-154 |
| `src/LTM/Usage.md` | L48-126 |
| `src/LTM/od_manager.py` | L1-45 |
| `src/LTM/link.py` | L187-226 |
| `src/LTM/path_finder.py` | L133-170 |
| `src/LTM/node.py` | L271-302 |
| `src/LTM/link.py` | L352-394 |

</details>

---

<think><details><summary>Thought Process</summary>Now I have a clearer picture of the issue. Looking at the `init_nodes_and_links` method in `network.py`, I can see the problem:

```python
for i in range(num_nodes):
    # ... code ...
    for j in range(i+1, num_nodes):  # Only upper triangular
        if self.adjacency_matrix[i, j] == 1:
            # Get link-specific parameters
            link_params = self.params.get('links', {}).get(f'{i}_{j}', 
                        self.params.get('default_link', {}))
```

The issue is that when `j > i`, it only looks for link parameters with the key `f'{i}_{j}'` (e.g., '2_3'), but if a user defines parameters for the reverse direction like '3_2', they won't be found because the code only processes the upper triangle.

The key problems are:

1. **Parameter lookup**: When creating the forward link (i->j), it only looks for parameters under the key `f'{i}_{j}'`, not considering `f'{j}_{i}'`
2. **Bidirectional parameters**: Both forward and reverse links use the same parameters from the forward direction, but users might want to specify different parameters for each direction

Let me suggest a solution that addresses both issues.</details></think>

---

You're absolutely right! The current code only iterates through the upper triangular part of the adjacency matrix (`j > i`), which means link-specific parameters defined as '3_2' won't be processed because it only looks for '2_3'. This creates an asymmetric parameter assignment issue.

---

Read file: src/LTM/network.py

---

<think><details><summary>Thought Process</summary>Now I can see the issue clearly. The problem is in the `init_nodes_and_links` method where it only looks for link parameters using the format `f'{i}_{j}'` but not the reverse `f'{j}_{i}'`. 

I can suggest several solutions:

1. **Enhanced parameter lookup**: For each link pair, check both directions (`f'{i}_{j}'` and `f'{j}_{i}'`) and use specific parameters if available
2. **Full matrix iteration**: Instead of only iterating the upper triangle, iterate the full adjacency matrix to handle asymmetric configurations
3. **Bidirectional parameter specification**: Allow separate parameters for forward and reverse links

Let me provide a comprehensive solution that addresses all these issues.</details></think>

---

Here's my suggestion to improve the link creation logic to handle asymmetric parameter assignments properly:

```python:src/LTM/network.py
def _get_link_params(self, i: int, j: int, direction: str = 'forward') -> dict:
    """
    Get link-specific parameters with enhanced lookup logic.
    
    Args:
        i: Start node
        j: End node  
        direction: 'forward' for i->j, 'reverse' for j->i
        
    Returns:
        dict: Link parameters
    """
    links_config = self.params.get('links', {})
    default_params = self.params.get('default_link', {})
    
    if direction == 'forward':
        # For forward link (i->j), check both i_j and j_i keys
        forward_key = f'{i}_{j}'
        reverse_key = f'{j}_{i}'
        
        # First try the natural direction key
        if forward_key in links_config:
            return {**default_params, **links_config[forward_key]}
        # If not found, try reverse direction key (for backward compatibility)
        elif reverse_key in links_config:
            self.logger.warning(f"Using reverse key '{reverse_key}' for forward link '{forward_key}'. "
                              f"Consider using '{forward_key}' instead.")
            return {**default_params, **links_config[reverse_key]}
        else:
            return default_params
            
    else:  # direction == 'reverse'
        # For reverse link (j->i), check both j_i and i_j keys
        reverse_key = f'{j}_{i}'
        forward_key = f'{i}_{j}'
        
        # First try the natural direction key
        if reverse_key in links_config:
            return {**default_params, **links_config[reverse_key]}
        # If not found, use forward direction params (current behavior)
        elif forward_key in links_config:
            return {**default_params, **links_config[forward_key]}
        else:
            return default_params

def init_nodes_and_links(self):
    """Initialize nodes and links based on the adjacency matrix."""
    num_nodes = self.adjacency_matrix.shape[0]
    created_nodes = []

    for i in range(num_nodes):
        if i in created_nodes:
            node = self.nodes[i]
        else:
            node = self._create_nodes(i)
            created_nodes.append(i)
            self.nodes[i] = node

        for j in range(i+1, num_nodes):
            if self.adjacency_matrix[i, j] == 1:
                # Create forward link (i->j)
                if j not in created_nodes:
                    node_j = self._create_nodes(j)
                    created_nodes.append(j)
                    self.nodes[j] = node_j
                
                # Get parameters for both directions
                forward_params = self._get_link_params(i, j, 'forward')
                reverse_params = self._get_link_params(i, j, 'reverse')
                
                # Determine link types (can be different for each direction)
                forward_type = forward_params.get('controller_type', 'gate')
                reverse_type = reverse_params.get('controller_type', 'gate')
                
                # Create forward link (i->j)
                if forward_type == 'separator':
                    forward_link = Separator(f"{i}_{j}", node, self.nodes[j], 
                                           self.simulation_steps, self.unit_time, **forward_params)
                elif forward_type == 'gate':
                    forward_link = Link(f"{i}_{j}", node, self.nodes[j], 
                                      self.simulation_steps, self.unit_time, **forward_params)
                else:
                    raise ValueError(f"Invalid controller type for link {i}_{j}: {forward_type}")
                
                # Create reverse link (j->i)
                if reverse_type == 'separator':
                    reverse_link = Separator(f"{j}_{i}", self.nodes[j], node, 
                                           self.simulation_steps, self.unit_time, **reverse_params)
                elif reverse_type == 'gate':
                    reverse_link = Link(f"{j}_{i}", self.nodes[j], node, 
                                      self.simulation_steps, self.unit_time, **reverse_params)
                else:
                    raise ValueError(f"Invalid controller type for link {j}_{i}: {reverse_type}")
                
                # Add links to nodes
                node.outgoing_links.append(forward_link)
                self.nodes[j].incoming_links.append(forward_link)
                node.incoming_links.append(reverse_link)
                self.nodes[j].outgoing_links.append(reverse_link)
                
                # Store links and set reverse links
                self.links[(i, j)] = forward_link
                self.links[(j, i)] = reverse_link
                forward_link.reverse_link = reverse_link
                reverse_link.reverse_link = forward_link

        node.init_node()
```

**Key improvements:**

1. **Enhanced Parameter Lookup**: The new `_get_link_params()` method checks both directions (`'2_3'` and `'3_2'`) for each link, with priority given to the natural direction.

2. **Bidirectional Configuration**: You can now specify different parameters for each direction:
   ```python
   params = {
       'links': {
           '2_3': {  # Forward direction
               'width': 2,
               'controller_type': 'gate'
           },
           '3_2': {  # Reverse direction  
               'width': 1.5,
               'controller_type': 'separator'
           }
       }
   }
   ```

3. **Backward Compatibility**: If you specify parameters using the "wrong" direction (e.g., `'3_2'` when the iteration creates `'2_3'` first), it will still work but issue a warning.

4. **Independent Link Types**: Forward and reverse links can now have different controller types and parameters.

This solution addresses the asymmetric parameter assignment issue while maintaining backward compatibility with existing configurations. The enhanced lookup logic ensures that link-specific parameters are found regardless of how they're specified in the configuration.

---

_**User**_

@ network, so if I assume that the forward link's params should be identical to its reverse link params, can you simplify the change?

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user is asking for a simplified version where forward and reverse links share identical parameters. This makes sense because in most pedestrian traffic scenarios, the physical properties of a corridor/link would be the same in both directions - the length, width, free flow speed, etc. would typically be identical.

So instead of having separate parameter lookups for forward and reverse directions, I can simplify this to:
1. Look up parameters for the link pair (checking both i_j and j_i keys)
2. Use the same parameters for both forward and reverse links

This is much simpler than my previous solution.</details></think>

---

Absolutely! If forward and reverse links should have identical parameters, the solution becomes much simpler. Here's the streamlined approach:

```python:src/LTM/network.py
def _get_link_params(self, i: int, j: int) -> dict:
    """
    Get link-specific parameters, checking both direction keys.
    
    Args:
        i: First node
        j: Second node
        
    Returns:
        dict: Link parameters (same for both directions)
    """
    links_config = self.params.get('links', {})
    default_params = self.params.get('default_link', {})
    
    # Check both possible keys: i_j and j_i
    forward_key = f'{i}_{j}'
    reverse_key = f'{j}_{i}'
    
    if forward_key in links_config:
        return {**default_params, **links_config[forward_key]}
    elif reverse_key in links_config:
        return {**default_params, **links_config[reverse_key]}
    else:
        return default_params

def init_nodes_and_links(self):
    """Initialize nodes and links based on the adjacency matrix."""
    num_nodes = self.adjacency_matrix.shape[0]
    created_nodes = []

    for i in range(num_nodes):
        if i in created_nodes:
            node = self.nodes[i]
        else:
            node = self._create_nodes(i)
            created_nodes.append(i)
            self.nodes[i] = node

        for j in range(i+1, num_nodes):
            if self.adjacency_matrix[i, j] == 1:
                # Create forward link (i->j)
                if j not in created_nodes:
                    node_j = self._create_nodes(j)
                    created_nodes.append(j)
                    self.nodes[j] = node_j
                
                # Get shared parameters for both directions
                link_params = self._get_link_params(i, j)
                link_type = link_params.get('controller_type', 'gate')
                
                # Create both links with identical parameters
                if link_type == 'separator':
                    forward_link = Separator(f"{i}_{j}", node, self.nodes[j], 
                                           self.simulation_steps, self.unit_time, **link_params)
                    reverse_link = Separator(f"{j}_{i}", self.nodes[j], node, 
                                           self.simulation_steps, self.unit_time, **link_params)
                elif link_type == 'gate':
                    forward_link = Link(f"{i}_{j}", node, self.nodes[j], 
                                      self.simulation_steps, self.unit_time, **link_params)
                    reverse_link = Link(f"{j}_{i}", self.nodes[j], node, 
                                      self.simulation_steps, self.unit_time, **link_params)
                else:
                    raise ValueError(f"Invalid controller type: {link_type}")
                
                # Add links to nodes
                node.outgoing_links.append(forward_link)
                self.nodes[j].incoming_links.append(forward_link)
                node.incoming_links.append(reverse_link)
                self.nodes[j].outgoing_links.append(reverse_link)
                
                # Store links and set reverse links
                self.links[(i, j)] = forward_link
                self.links[(j, i)] = reverse_link
                forward_link.reverse_link = reverse_link
                reverse_link.reverse_link = forward_link

        node.init_node()
```

**Key changes:**

1. **Single Parameter Lookup**: `_get_link_params()` checks both `'i_j'` and `'j_i'` keys and returns the same parameters for both directions.

2. **Simplified Logic**: No need for direction-specific parameter handling since both links use identical parameters.

3. **Flexible Configuration**: Now you can specify link parameters as either `'2_3'` or `'3_2'` and they'll be found regardless of the iteration order.

**Example usage:**
```python
params = {
    'links': {
        '3_2': {  # Will work even though iteration creates 2_3 first
            'width': 1,
            'controller_type': 'separator'
        }
    }
}
```

This simplified approach maintains the fix for the asymmetric parameter assignment issue while keeping the assumption that bidirectional links share identical physical properties.

---

_**User**_

what is this mean

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user is asking "what is this mean" in reference to the code changes they made to the network.py file. Looking at the attached files, I can see they've implemented the simplified version I suggested for handling symmetric link parameters. They want me to explain what these changes mean and accomplish.

Let me break down what these changes do:

1. The _get_link_params method was simplified to remove the direction parameter
2. The logic now checks both possible keys (i_j and j_i) and returns the same parameters for both directions
3. The init_nodes_and_links method was simplified to use shared parameters for both forward and reverse links
4. The code is now much cleaner and handles the asymmetric parameter assignment issue

I should explain this clearly and concisely.</details></think>

---

The changes you made implement the simplified solution I suggested to fix the asymmetric parameter assignment issue. Here's what they mean:

## **Problem Solved**
Previously, if you specified link parameters as `'3_2'`, they wouldn't be found because the code only looked for `'2_3'` when iterating the upper triangular matrix.

## **What the Changes Do**

### 1. **Simplified Parameter Lookup**
```python
def _get_link_params(self, i: int, j: int) -> dict:
```
- Removed the `direction` parameter 
- Now checks **both** `'i_j'` and `'j_i'` keys in the links configuration
- Returns the **same parameters** for both forward and reverse links

### 2. **Bidirectional Parameter Sharing**
```python
# Get shared parameters for both directions
link_params = self._get_link_params(i, j)
link_type = link_params.get('controller_type', 'gate')

# Create both links with identical parameters
if link_type == 'separator':
    forward_link = Separator(f"{i}_{j}", ..., **link_params)
    reverse_link = Separator(f"{j}_{i}", ..., **link_params)
```
- Both forward (`2_3`) and reverse (`3_2`) links now use **identical parameters**
- Much simpler logic - no separate parameter handling for each direction

## **Practical Result**
Now you can specify link parameters using **either direction** and they'll be found:

```python
params = {
    'links': {
        '3_2': {  # âœ… This will now work!
            'width': 1,
            'controller_type': 'separator'
        }
    }
}
```

The system will find these parameters regardless of whether the iteration creates `'2_3'` or `'3_2'` first, solving the original asymmetric parameter assignment problem while keeping the code clean and simple.

---

_**User**_

return {**default_params, **links_config[forward_key]} what is this code mean

---

_**Assistant**_

This is Python dictionary unpacking syntax. Let me break it down:

1. `**` is the dictionary unpacking operator
2. The expression `{**dict1, **dict2}` creates a new dictionary by merging `dict1` and `dict2`
3. If there are duplicate keys, the values from `dict2` override those from `dict1`

Here's a concrete example:

```python
# Default parameters
default_params = {
    'length': 50,
    'width': 1,
    'free_flow_speed': 1.1,
    'k_critical': 2,
    'k_jam': 6
}

# Link-specific configuration
links_config = {
    '2_3': {
        'width': 2,  # This will override the default width
        'controller_type': 'separator'  # This is a new parameter
    }
}

# When the code runs:
forward_key = '2_3'
result = {**default_params, **links_config[forward_key]}

# The result will be:
{
    'length': 50,          # from default_params
    'width': 2,           # from links_config (overrides default)
    'free_flow_speed': 1.1, # from default_params
    'k_critical': 2,       # from default_params
    'k_jam': 6,           # from default_params
    'controller_type': 'separator'  # from links_config (new parameter)
}
```

This is equivalent to, but more concise than:
```python
result = default_params.copy()  # Create a copy of default parameters
result.update(links_config[forward_key])  # Update with link-specific parameters
```

The advantage of this approach is that:
1. It preserves all default parameters
2. Allows overriding specific parameters for individual links
3. Allows adding new parameters not present in the defaults
4. Creates a new dictionary without modifying the original dictionaries

This is particularly useful in your code because each link can customize certain parameters while inheriting all other default values.

---

_**User**_

change this code to get the param value from the links' params

---

_**Assistant**_

I'll modify the code to get these parameters from the network configuration. Here's how we can do it:

First, let's modify the PathFinder initialization in `path_finder.py`:

```python:src/LTM/path_finder.py
class PathFinder:
    """Handles path finding and path-related operations"""
    def __init__(self, links, params=None):
        self.od_paths = {}  # {(origin, dest): [path1, path2, ...]}
        self.graph = self._create_graph(links)
        self.links = links
        self.nodes_in_paths = set()
        self.node_turn_probs = {}  # {node_id: {(o,d): {(up_node, down_node): probability}}}
        self.node_to_od_pairs = {}  # {node_id: set((o1,d1), (o2,d2), ...)}, to get the relevant od pairs for the node
        self._initialized = False  # Add initialization flag

        # Get parameters from config or use defaults
        path_params = params.get('path_finder', {}) if params else {}
        self.theta = path_params.get('theta', 0.1)  # like the temperature in the logit model
        self.alpha = path_params.get('alpha', 1.0)  # distance weight
        self.beta = path_params.get('beta', 0.05)   # congestion weight
```

Then in `network.py`, we need to pass the parameters when creating the PathFinder:

```python:src/LTM/network.py
def init_nodes_and_links(self):
    """Initialize network structure"""
    # ... existing code ...

    # Initialize managers if destination nodes are specified
    if destination_nodes:
        self.od_manager = ODManager(self.simulation_steps, logger=self.logger)
        self.od_manager.init_od_flows(origin_nodes, destination_nodes, od_flows)
    
        self.path_finder = PathFinder(self.links, params=self.params)  # Pass params here
```

Now you can configure these parameters in your network configuration:

```python
params = {
    'unit_time': 10,
    'simulation_steps': 600,
    'path_finder': {
        'theta': 0.2,      # Custom temperature parameter
        'alpha': 0.8,      # Custom distance weight
        'beta': 0.1        # Custom congestion weight
    },
    'default_link': {
        'length': 50,
        'width': 1,
        # ... other link parameters ...
    }
}
```

This change allows you to:
1. Configure path finding parameters through the network configuration
2. Keep default values if not specified
3. Make the parameters easily adjustable without changing code

The parameters will affect how paths are chosen:
- `theta`: Controls the randomness in path selection (higher = more random)
- `alpha`: Weight for distance-based costs (higher = more emphasis on shorter paths)
- `beta`: Weight for congestion-based costs (higher = more emphasis on avoiding congested paths)

---

